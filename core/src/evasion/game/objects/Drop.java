package evasion.game.objects;

import com.badlogic.gdx.graphics.g2d.*;
import com.badlogic.gdx.math.Intersector;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Pool;
import evasion.game.Constants;
import evasion.game.Evasion;
import evasion.utils.Collidable;
import evasion.utils.CollisionType;
import evasion.utils.DrawLevel;
import evasion.utils.DropType;

/**
 * Drops that are generated by destroyed asteroids
 */
public class Drop extends GameObject implements Pool.Poolable {

    private DropType dropType;

    private int speed;

    private TextureAtlas textureAtlasMoney;
    private Animation animation;
    private TextureRegion[] textureRegions;
    private TextureRegion currentFrame;
    private Sprite image;

    private boolean addedToCollidables; //fixes java.util.ConcurrentModificationException

    private Rectangle bounds;

    private boolean flip, addMoney;

    private float stateTime;

    public Drop(Evasion game) {
        super(DrawLevel.OBJECTS, game);
        flip = false;
    }

    public void init(Vector2 position, int speed, DropType dropType) {
        this.position = position;
        velocity = new Vector2(0, speed);
        this.dropType = dropType;
        setAddedToCollidables(false);
        setLiving(true);
        addMoney = false;
        load();
    }

    private void load() {
        switch (dropType) {
            case POWER_UP:
                break;
            case MONEY:
                textureAtlasMoney = game.manager.get("images/drops/coins.pack", TextureAtlas.class);
                textureRegions = new TextureRegion[textureAtlasMoney.findRegions("coin").size];
                for (int i=0; i<textureAtlasMoney.findRegions("coin").size; i++) {
                    textureRegions[i] = textureAtlasMoney.findRegion("coin", i);
                }
                animation = new Animation(0.1f, textureRegions);
                animation.setPlayMode(Animation.PlayMode.LOOP_PINGPONG);
                currentFrame = animation.getKeyFrame(stateTime);
                image = new Sprite(animation.getKeyFrame(0, true));
                bounds = image.getBoundingRectangle();
                break;
        }
    }

    @Override
    public Rectangle getBounds() {
        return bounds;
    }

    @Override
    public void collideWith(Collidable collidable) {
        if (Intersector.overlaps(collidable.getBounds(), bounds)) {
            switch (collidable.getCollisionType()) {
                case PLAYER:
                    if (dropType == DropType.MONEY) addMoney = true;
                    collide();
                    break;
                case ASTEROID:
                    collidable.collide();
                    break;
                case MINE:
                    break;
                case DROP:
                    break;
                case LASER:
                    break;
            }
        }
    }

    @Override
    public void collide() {
        setLiving(false);
    }

    @Override
    public CollisionType getCollisionType() {
        return CollisionType.DROP;
    }

    @Override
    public DrawLevel getDrawLevel() {
        return drawLevel;
    }

    @Override
    public void draw(Batch batch) {
        image.draw(batch);
    }

    @Override
    public void update(float delta) {
        //  velocity.scl(delta) accounts for time.
        position.add(velocity.scl(delta));
        velocity.scl(1 / delta); //unscales velocity vector

        stateTime += delta;

        //setting the current frame
        currentFrame = animation.getKeyFrame(stateTime, true);

        //flips animation
        if (!flip && animation.getKeyFrameIndex(stateTime) == 5) {
            flip = true;
        }else if (flip && animation.getKeyFrameIndex(stateTime) == 0) {
            flip = false;
        }
        if (flip) {
            currentFrame.flip(true, false);
        }

        //set new frame and bounds
        image = new Sprite(currentFrame);
        image.scale(Constants.MONEY_SCALE);
        bounds = image.getBoundingRectangle();
        image.setPosition(position.x, position.y);
        bounds.setPosition(position);

        checkIfInScreen();
    }

    private void checkIfInScreen() {
        if (bounds.getY() < -bounds.getHeight()) {
            setLiving(false);
        }
    }

    /**
     * Resets the object for reuse. Object references should be nulled and fields may be set to default values.
     */
    @Override
    public void reset() {
        position.set(-100.0f, 200.0f);
        velocity.set(0,0);
    }

    public boolean isAddedToCollidables() {
        return addedToCollidables;
    }

    public void setAddedToCollidables(boolean addedToCollidables) {
        this.addedToCollidables = addedToCollidables;
    }

    public boolean AddMoney() {
        return addMoney;
    }

}
